class(NoMatchFor < RuntimeError):
  initialize(@input) := #ok

  message :=
    "no matchers succeeded for: " +
      @input slice(0, 50) + " [...]"


module(HL):
  data(Object):
    Matcher(@regexp, @type, @next)

  module(Lexers):
    class(Lexer):
      define(initialize(@input)):
        @state = [
          class matchers fetch(class info fetch(#start)) call
        ] -- [Matcher]

        @lexed = [] -- [Token]

      -- run the lexer until the input is empty, yielding
      -- the lexed tokens
      define(run):
        while(!(@input empty?)):
          try-all(@state last)

        @lexed

      -- go through matchers until one matches the immediate
      -- next input. if none match, try again, but allowing
      -- matches past the start. see #try-all-first.
      try-all(ms) := do:
        closest = nil
        worked = nil

        ms each (m):
          m regexp match(@input) match:
            -- only allow a match that's at the start of the input
            (d: MatchData ? pre-match empty?) -> do:
              @input slice!(0, d to-s size)

              m next apply(@state, d)

              tokens(d, m type)

              return(true)

            -- matched, but not at the start; set the closest match
            -- information in case of failure
            (d: MatchData ?
              closest nil? ||
                pre-match size < closest pre-match size) -> do:
              closest =! d
              worked =! m

        if(closest nil?)
          then: raise(NoMatchFor new(@input))
          else:
            skipped = closest pre-match
            @input = closest post-match

            worked next apply(@state, closest)

            @lexed << HL::Tokens::Token new(
              HL::Tokens::Tagged new("err")
              skipped
            )

            tokens(closest, worked type)

            return(false)

      -- TODO: Using
      tokens(data, gs: HL::Tokens::ByGroups) :=
        gs types zip(data to-a drop(1)) ([t, d]):
          when(t nil? || d nil?):
            return(nil)

          @lexed << HL::Tokens::Token new(t, d)

      tokens(data, t: HL::Tokens::Tagged) :=
        @lexed << HL::Tokens::Token new(t, data to-s)

      class(<< self):
        attr-accessor(#matchers, #info)

        name(&x) :=
          @info at(#name) put(x call)

        aliases(&x) :=
          @info at(#aliases) put(Array(x call))

        extensions(&x) :=
          @info at(#extensions) put(Array(x call))

        mimetypes(&x) :=
          @info at(#mimetypes) put(Array(x call))

        start(&x) :=
          @info at(#start) put(x call)

        flags(&x) :=
          @info at(#flags) put(x call)
