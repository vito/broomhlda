class(NoMatchFor < RuntimeError):
  initialize(@input) := #ok

  message :=
    "no matchers succeeded for: " +
      @input slice(0, 50) + " [...]"


module(HL):
  data(Object):
    Matcher(@regexp, @type, @next)

  module(Lexers):
    class(Lexer):
      define(initialize(@input)):
        @state = [
          class matchers fetch(class info fetch(#start)) call
        ] -- [Matcher]

        @lexed = [] -- [Token]

      -- run the lexer until the input is empty, yielding
      -- the lexed tokens
      define(run):
        while(!(@input empty?)):
          try-all(@state last)

        @lexed

      -- go through matchers until one matches the immediate
      -- next input. if none match, try again, but allowing
      -- matches past the start. see #try-all-first.
      try-all([]) :=
        raise(NoMatchFor new(@input))
      try-all((x: Array) . xs) :=
        try-all(x + xs)
      try-all(m . ms) :=
        m regexp match(@input) match:
          -- only allow a match that's at the start of the input
          (d: MatchData ? pre-match empty?) -> do:
            @input slice!(0, d to-s size)

            apply(m next, d)

            tokens(d, m type)

          -- no match; try the rest, and if none work,
          -- start matching again but with #try-all-first.
          _ ->
            begin: try-all(ms);
              rescue (e):
                e match:
                  NoMatchFor ->
                    try-all-first([m] + ms)

                  _ -> raise(e)

      -- TODO: Using
      tokens(data, gs: HL::Tokens::ByGroups) :=
        gs types zip(data to-a drop(1)) ([t, d]):
          when(t nil? || d nil?):
            return(nil)

          @lexed << HL::Tokens::Token new(t, d)

      tokens(data, t: HL::Tokens::Tagged) :=
        @lexed << HL::Tokens::Token new(t, data to-s)

      -- like try-all, but it goes with the first matching
      -- segment, with the contents before it as an Error
      -- token (ie, it's not anchored to the beginning)
      try-all-first([]) :=
        raise(NoMatchFor new(@input))
      try-all-first((x: Array) . xs) :=
        try-all-first(x + xs)
      try-all-first(m . ms) :=
        m regexp match(@input) match:
          (d: MatchData) -> do:
            skipped = d pre-match
            @input = d post-match

            apply(m next, d) -- TODO?: highlighter doesn't do this

            @lexed << HL::Tokens::Token new(
              HL::Tokens::Tagged new("err")
              skipped
            )

            tokens(d, m type)

          _ -> try-all-first(ms)

      class(<< self):
        attr-accessor(#matchers, #info)

        name(&x) :=
          @info at(#name) put(x call)

        aliases(&x) :=
          @info at(#aliases) put(Array(x call))

        extensions(&x) :=
          @info at(#extensions) put(Array(x call))

        mimetypes(&x) :=
          @info at(#mimetypes) put(Array(x call))

        start(&x) :=
          @info at(#start) put(x call)

        flags(&x) :=
          @info at(#flags) put(x call)
