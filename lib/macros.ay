macro(lexer(~name) { ~*body }):
  `(class(~name < HL::Lexers::Lexer):
      @matchers = Hash new
      @info = Hash new

      ~*body)

for-macro:
  short-name(["name", "constant"]) := "no"
  short-name(["name", "entity"]) := "ni"
  short-name(["name", "property"]) := "py"
  short-name(["literal", b]) := short-name([b])
  short-name([a, "other"]) := short-name([a]) + "x"
  short-name([a, "error"]) := short-name([a]) + "r"
  short-name([a, "single"]) := short-name([a]) + "1"
  short-name([a, "double"]) := short-name([a]) + "2"
  short-name([a, b]) := short-name([a]) + short-name([b])
  short-name(["error"]) := "err"
  short-name(["number"]) := "m"
  short-name([x]) := x slice(0, 1)
  short-name(_ . xs) := short-name(xs)

  type-from(x: Atomy::AST::Word) := do:
    tag = short-name(x text split("."))
    `(HL::Tokens::Tagged new(~tag))

  type-from(`(by-groups(~*args))) :=
    `(HL::Tokens::ByGroups new([~*(args collect [a]: type-from(a))]))

  type-from(`(using(~who))) :=
    `(HL::Tokens::Using new(~who))

  type-from(x) := raise("unknown match type: " + x inspect)

  regexp-from(x) :=
    `([x]: Regexp new(
        x source
        x options | @info fetch(#flags)
      ); call(~x))

  state-from('pop) := '(HL::States::Pop new)
  state-from(`(pop(~n))) := `(HL::States::PopNum new(~n))
  state-from('push) := '(HL::States::Push new)
  state-from(`(do-all(~*args))) :=
    `(HL::States::DoAll new(~(args collect [a]: state-from(a))))
  state-from(`(combined(~*args))) := do:
    all = args reverse collect [a]:
      `(@matchers fetch(#~a))

    `(HL::States::Combined new(~all))
  state-from(`(go-to(~n))) :=
    `(HL::States::GoTo new(@matchers, #~n))
  state-from(x) :=
    raise("unknown state: " + x inspect)


macro(lex(~name) { ~*tokens }):
  `(lex(~name) [] { ~*tokens })

macro(lex(~name) [~*args] { ~*tokens }):
  branches = Array[]

  body = Array[]

  tokens each [c]:
    c match:
      -- implicit continue state
      `(~x is(~y)) ->
        branches <<
          `(HL::Matcher new(
              ~(regexp-from(x))
              ~(type-from(y))
              HL::States::Continue new
            ))

      -- specifying a state
      `(~x is(~y) -> ~z) -> do:
        branches <<
          `(HL::Matcher new(
              ~(regexp-from(x))
              ~(type-from(y))
              ~(state-from(z))
            ))

      -- goto shortcut
      `(~x is(~y) => ~z) ->
        branches <<
          `(HL::Matcher new(
              ~(regexp-from(x))
              ~(type-from(y))
              HL::States::GoTo new(@matchers, #~z)
            ))

      `(any-of(~any)) ->
        branches <<
          `(@matchers fetch(#~any) call) -- TODO: parameterization?

      _ -> body << c

  body << `([~*branches] flatten)

  `(@matchers [#~name] = [~*args] { ~*body })
