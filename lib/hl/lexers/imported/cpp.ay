use("atomy")
use("hl/define")

Lexer = lexer:
name: "C++"
aliases: ["cpp", "c++"]
extensions: [".cpp", ".hpp", ".c++", ".h++", ".cc", ".hh", ".cxx", ".hxx"]
mimetypes: ["text/x-c++hdr", "text/x-c++src"]
start: .root
flags: 0

lex(classname):
  r"[a-zA-Z_][a-zA-Z0-9_]*" is(name.class) -> pop
  r"\s*(?=>)" is(text) -> pop

lex(macro):
  r"[^/\n]+" is(comment.preproc)
  r"/[*](.|\n)*?[*]/" is(comment.multiline)
  r"//.*?\n" is(comment.single) -> pop
  r"/" is(comment.preproc)
  r"(?<=\\)\n" is(comment.preproc)
  r"\n" is(comment.preproc) -> pop

lex(root):
  r"^\#if\s+0" is(comment.preproc) -> go-to(if0)
  r"^\#" is(comment.preproc) -> go-to(macro)
  r"^((?:\s|//.*?\n|/[*].*?[*]/)+)(\#if\s+0)" is(by-groups(using(self class), comment.preproc)) -> go-to(if0)
  r"^((?:\s|//.*?\n|/[*].*?[*]/)+)(\#)" is(by-groups(using(self class), comment.preproc)) -> go-to(macro)
  r"\n" is(text)
  r"\s+" is(text)
  r"\\\n" is(text)
  r"/(\\\n)?/(\n|(.|\n)*?[^\\]\n)" is(comment.single)
  r"/(\\\n)?[*](.|\n)*?[*](\\\n)?/" is(comment.multiline)
  r"[{}]" is(punctuation)
  r"L?\"" is(literal.string) -> go-to(string)
  r"L?'(\\.|\\[0-7]{1,3}|\\x[a-fA-F0-9]{1,2}|[^\\\'\n])'" is(literal.string.char)
  r"(\d+\.\d*|\.\d+|\d+)[eE][+-]?\d+[LlUu]*" is(literal.number.float)
  r"(\d+\.\d*|\.\d+|\d+[fF])[fF]?" is(literal.number.float)
  r"0x[0-9a-fA-F]+[LlUu]*" is(literal.number.hex)
  r"0[0-7]+[LlUu]*" is(literal.number.oct)
  r"\d+[LlUu]*" is(literal.number.integer)
  r"\*/" is(error)
  r"[\126!%^&*+=|?:<>/-]" is(operator)
  r"[()\[\],.;]" is(punctuation)
  r"(asm|auto|break|case|catch|const|const_cast|continue|default|delete|do|dynamic_cast|else|enum|explicit|export|extern|for|friend|goto|if|mutable|namespace|new|operator|private|protected|public|register|reinterpret_cast|return|restrict|sizeof|static|static_cast|struct|switch|template|this|throw|throws|try|typedef|typeid|typename|union|using|volatile|virtual|while)\b" is(keyword)
  r"(class)(\s+)" is(by-groups(keyword, text)) -> go-to(classname)
  r"(bool|int|long|float|short|double|char|unsigned|signed|void|wchar_t)\b" is(keyword.type)
  r"(_{0,2}inline|naked|thread)\b" is(keyword.reserved)
  r"__(asm|int8|based|except|int16|stdcall|cdecl|fastcall|int32|declspec|finally|int64|try|leave|wchar_t|w64|virtual_inheritance|uuidof|unaligned|super|single_inheritance|raise|noop|multiple_inheritance|m128i|m128d|m128|m64|interface|identifier|forceinline|event|assume)\b" is(keyword.reserved)
  r"(__offload|__blockingoffload|__outer)\b" is(keyword.pseudo)
  r"(true|false)\b" is(keyword.constant)
  r"NULL\b" is(name.builtin)
  r"[a-zA-Z_][a-zA-Z0-9_]*:(?!:)" is(name.label)
  r"[a-zA-Z_][a-zA-Z0-9_]*" is(name)

lex(string):
  r"\"" is(literal.string) -> pop
  r"\\([\\abfnrtv\"\']|x[a-fA-F0-9]{2,4}|[0-7]{1,3})" is(literal.string.escape)
  r"[^\\\"\n]+" is(literal.string)
  r"\\\n" is(literal.string)
  r"\\" is(literal.string)

lex(if0):
  r"^\s*\#if.*?(?<!\\)\n" is(comment.preproc) -> push
  r"^\s*\#endif.*?(?<!\\)\n" is(comment.preproc) -> pop
  r".*?\n" is(comment)

