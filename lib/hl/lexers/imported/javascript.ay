use("atomy")
use("hl/define")

Lexer = lexer:
name: "JavaScript"
aliases: ["js", "javascript"]
extensions: [".js"]
mimetypes: ["application/javascript", "application/x-javascript", "text/x-javascript", "text/javascript"]
start: .root
flags: Regexp::MULTILINE

lex(commentsandwhitespace):
  Regexp new("\\s+") is(text)
  Regexp new("<!--") is(comment)
  Regexp new("//.*?\\n") is(comment.single)
  Regexp new("/\\*.*?\\*/") is(comment.multiline)

lex(root):
  Regexp new("^(?=\\s|/|<!--)") is(text) -> go-to(slashstartsregex)
  any-of(commentsandwhitespace)
  Regexp new("\\+\\+|--|\126|&&|\\?|:|\\|\\||\\\\(?=\\n)|(<<|>>>?|==?|!=?|[-<>+*%&\\|\\^/])=?") is(operator) -> go-to(slashstartsregex)
  Regexp new("[{(\\[;,]") is(punctuation) -> go-to(slashstartsregex)
  Regexp new("[})\\].]") is(punctuation)
  Regexp new("(for|in|while|do|break|return|continue|switch|case|default|if|else|throw|try|catch|finally|new|delete|typeof|instanceof|void|this)\\b") is(keyword) -> go-to(slashstartsregex)
  Regexp new("(var|with|function)\\b") is(keyword.declaration) -> go-to(slashstartsregex)
  Regexp new("(abstract|boolean|byte|char|class|const|debugger|double|enum|export|extends|final|float|goto|implements|import|int|interface|long|native|package|private|protected|public|short|static|super|synchronized|throws|transient|volatile)\\b") is(keyword.reserved)
  Regexp new("(true|false|null|NaN|Infinity|undefined)\\b") is(keyword.constant)
  Regexp new("(Array|Boolean|Date|Error|Function|Math|netscape|Number|Object|Packages|RegExp|String|sun|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|Error|eval|isFinite|isNaN|parseFloat|parseInt|document|this|window)\\b") is(name.builtin)
  Regexp new("[$a-zA-Z_][a-zA-Z0-9_]*") is(name.other)
  Regexp new("[0-9][0-9]*\\.[0-9]+([eE][0-9]+)?[fd]?") is(literal.number.float)
  Regexp new("0x[0-9a-fA-F]+") is(literal.number.hex)
  Regexp new("[0-9]+") is(literal.number.integer)
  Regexp new("\"(\\\\\\\\|\\\\\"|[^\"])*\"") is(literal.string.double)
  Regexp new("'(\\\\\\\\|\\\\'|[^'])*'") is(literal.string.single)

lex(slashstartsregex):
  any-of(commentsandwhitespace)
  Regexp new("/(\\\\.|[^\\[/\\\\\\n]|\\[(\\\\.|[^\\]\\\\\\n])*])+/([gim]+\\b|\\B)") is(literal.string.regex) -> pop
  Regexp new("(?=/)") is(text) -> do-all(pop, go-to(badregex))
  Regexp new("") is(text) -> pop

lex(badregex):
  Regexp new("\10") is(text) -> pop

