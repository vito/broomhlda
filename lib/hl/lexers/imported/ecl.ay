use("atomy")
use("hl/define")

Lexer = lexer:
name: "ECL"
aliases: ["ecl"]
extensions: [".ecl"]
mimetypes: ["application/x-ecl"]
start: .root
flags: Regexp IGNORECASE

lex(functions):
  r"(ABS|ACOS|ALLNODES|ASCII|ASIN|ASSTRING|ATAN|ATAN2|AVE|CASE|CHOOSE|CHOOSEN|CHOOSESETS|CLUSTERSIZE|COMBINE|CORRELATION|COS|COSH|COUNT|COVARIANCE|CRON|DATASET|DEDUP|DEFINE|DENORMALIZE|DISTRIBUTE|DISTRIBUTED|DISTRIBUTION|EBCDIC|ENTH|ERROR|EVALUATE|EVENT|EVENTEXTRA|EVENTNAME|EXISTS|EXP|FAILCODE|FAILMESSAGE|FETCH|FROMUNICODE|GETISVALID|GLOBAL|GRAPH|GROUP|HASH|HASH32|HASH64|HASHCRC|HASHMD5|HAVING|IF|INDEX|INTFORMAT|ISVALID|ITERATE|JOIN|KEYUNICODE|LENGTH|LIBRARY|LIMIT|LN|LOCAL|LOG|LOOP|MAP|MATCHED|MATCHLENGTH|MATCHPOSITION|MATCHTEXT|MATCHUNICODE|MAX|MERGE|MERGEJOIN|MIN|NOLOCAL|NONEMPTY|NORMALIZE|PARSE|PIPE|POWER|PRELOAD|PROCESS|PROJECT|PULL|RANDOM|RANGE|RANK|RANKED|REALFORMAT|RECORDOF|REGEXFIND|REGEXREPLACE|REGROUP|REJECTED|ROLLUP|ROUND|ROUNDUP|ROW|ROWDIFF|SAMPLE|SET|SIN|SINH|SIZEOF|SOAPCALL|SORT|SORTED|SQRT|STEPPED|STORED|SUM|TABLE|TAN|TANH|THISNODE|TOPN|TOUNICODE|TRANSFER|TRIM|TRUNCATE|TYPEOF|UNGROUP|UNICODEORDER|VARIANCE|WHICH|WORKUNIT|XMLDECODE|XMLENCODE|XMLTEXT|XMLUNICODE)\b" is(name.function)

lex(statements):
  any-of(types)
  any-of(keywords)
  any-of(functions)
  any-of(hash)
  r"\"" is(literal.string) -> go-to(string)
  r"\'" is(literal.string) -> go-to(string)
  r"(\d+\.\d*|\.\d+|\d+)[eE][+-]?\d+[LlUu]*" is(literal.number.float)
  r"(\d+\.\d*|\.\d+|\d+[fF])[fF]?" is(literal.number.float)
  r"0x[0-9a-fA-F]+[LlUu]*" is(literal.number.hex)
  r"0[0-7]+[LlUu]*" is(literal.number.oct)
  r"\d+[LlUu]*" is(literal.number.integer)
  r"\*/" is(error)
  r"[\126!%^&*+=|?:<>/-]+" is(operator)
  r"[{}()\[\],.;]" is(punctuation)
  r"[a-zA-Z_][a-zA-Z0-9_]*" is(name)

lex(whitespace):
  r"\s+" is(text)
  r"\/\/.*" is(comment.single)
  r"/(\\\n)?[*](.|\n)*?[*](\\\n)?/" is(comment.multiline)

lex(keywords):
  r"(APPLY|ASSERT|BUILD|BUILDINDEX|EVALUATE|FAIL|KEYDIFF|KEYPATCH|LOADXML|NOTHOR|NOTIFY|OUTPUT|PARALLEL|SEQUENTIAL|SOAPCALL|WAITCHECKPOINT|DEPRECATED|FAILCODE|FAILMESSAGE|FAILURE|GLOBAL|INDEPENDENT|ONWARNING|PERSIST|PRIORITY|RECOVERY|STORED|SUCCESS|WAIT|WHEN)\b" is(keyword.reserved)
  r"(ALL|AND|ANY|AS|ATMOST|BEFORE|BEGINC\+\+|BEST|BETWEEN|CASE|CONST|COUNTER|CSV|DESCEND|ENCRYPT|ENDC\+\+|ENDMACRO|EXCEPT|EXCLUSIVE|EXPIRE|EXPORT|EXTEND|FALSE|FEW|FIRST|FLAT|FULL|FUNCTION|GROUP|HEADER|HEADING|HOLE|IFBLOCK|IMPORT|IN|JOINED|KEEP|KEYED|LAST|LEFT|LIMIT|LOAD|LOCAL|LOCALE|LOOKUP|MACRO|MANY|MAXCOUNT|MAXLENGTH|MIN SKEW|MODULE|INTERFACE|NAMED|NOCASE|NOROOT|NOSCAN|NOSORT|NOT|OF|ONLY|OPT|OR|OUTER|OVERWRITE|PACKED|PARTITION|PENALTY|PHYSICALLENGTH|PIPE|QUOTE|RELATIONSHIP|REPEAT|RETURN|RIGHT|SCAN|SELF|SEPARATOR|SERVICE|SHARED|SKEW|SKIP|SQL|STORE|TERMINATOR|THOR|THRESHOLD|TOKEN|TRANSFORM|TRIM|TRUE|TYPE|UNICODEORDER|UNSORTED|VALIDATE|VIRTUAL|WHOLE|WILD|WITHIN|XML|XPATH|__COMPRESSED__)\b" is(keyword.reserved)

lex(hash):
  r"^\#.*$" is(comment.preproc)

lex(root):
  any-of(whitespace)
  any-of(statements)

lex(types):
  r"(RECORD|END)\D" is(keyword.declaration)
  r"((?:ASCII|BIG_ENDIAN|BOOLEAN|DATA|DECIMAL|EBCDIC|INTEGER|PATTERN|QSTRING|REAL|RECORD|RULE|SET OF|STRING|TOKEN|UDECIMAL|UNICODE|UNSIGNED|VARSTRING|VARUNICODE)\d*)(\s+)" is(by-groups(keyword.type, text))

lex(string):
  r"\"" is(literal.string) -> pop
  r"\'" is(literal.string) -> pop
  r"[^\"\']+" is(literal.string)

