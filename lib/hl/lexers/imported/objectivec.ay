use("atomy")
use("hl/define")

Lexer = lexer:
name: "Objective-C"
aliases: ["objective-c", "objectivec", "obj-c", "objc"]
extensions: [".m"]
mimetypes: ["text/x-objective-c"]
start: .root
flags: 0

lex(function):
  any-of(whitespace)
  any-of(statements)
  r";" is(punctuation)
  r"{" is(punctuation) -> push
  r"}" is(punctuation) -> pop

lex(statements):
  r"(L|@)?\"" is(literal.string) -> go-to(string)
  r"(L|@)?'(\\.|\\[0-7]{1,3}|\\x[a-fA-F0-9]{1,2}|[^\\\'\n])'" is(literal.string.char)
  r"(\d+\.\d*|\.\d+|\d+)[eE][+-]?\d+[lL]?" is(literal.number.float)
  r"(\d+\.\d*|\.\d+|\d+[fF])[fF]?" is(literal.number.float)
  r"0x[0-9a-fA-F]+[Ll]?" is(literal.number.hex)
  r"0[0-7]+[Ll]?" is(literal.number.oct)
  r"\d+[Ll]?" is(literal.number.integer)
  r"[\126!%^&*+=|?:<>/-]" is(operator)
  r"[()\[\],.]" is(punctuation)
  r"(auto|break|case|const|continue|default|do|else|enum|extern|for|goto|if|register|restricted|return|sizeof|static|struct|switch|typedef|union|volatile|virtual|while|in|@selector|@private|@protected|@public|@encode|@synchronized|@try|@throw|@catch|@finally|@end|@property|@synthesize|@dynamic)\b" is(keyword)
  r"(int|long|float|short|double|char|unsigned|signed|void|id|BOOL|IBOutlet|IBAction|SEL)\b" is(keyword.type)
  r"(_{0,2}inline|naked|restrict|thread|typename)\b" is(keyword.reserved)
  r"__(asm|int8|based|except|int16|stdcall|cdecl|fastcall|int32|declspec|finally|int64|try|leave)\b" is(keyword.reserved)
  r"(TRUE|FALSE|nil|NULL)\b" is(name.builtin)
  r"[a-zA-Z$_][a-zA-Z0-9$_]*:(?!:)" is(name.label)
  r"[a-zA-Z$_][a-zA-Z0-9$_]*" is(name)

lex(string):
  r"\"" is(literal.string) -> pop
  r"\\([\\abfnrtv\"\']|x[a-fA-F0-9]{2,4}|[0-7]{1,3})" is(literal.string.escape)
  r"[^\\\"\n]+" is(literal.string)
  r"\\\n" is(literal.string)
  r"\\" is(literal.string)

lex(classname):
  r"([a-zA-Z$_][a-zA-Z0-9$_]*)(\s*:\s*)([a-zA-Z$_][a-zA-Z0-9$_]*)?" is(by-groups(name.class, text, name.class)) -> pop
  r"([a-zA-Z$_][a-zA-Z0-9$_]*)(\s*)(\([a-zA-Z$_][a-zA-Z0-9$_]*\))" is(by-groups(name.class, text, name.label)) -> pop
  r"([a-zA-Z$_][a-zA-Z0-9$_]*)" is(name.class) -> pop

lex(forward-classname):
  r"([a-zA-Z$_][a-zA-Z0-9$_]*)(\s*,\s*)" is(by-groups(name.class, text)) -> go-to(forward-classname)
  r"([a-zA-Z$_][a-zA-Z0-9$_]*)(\s*;?)" is(by-groups(name.class, text)) -> pop

lex(if0):
  r"^\s*\#if.*?(?<!\\)\n" is(comment.preproc) -> push
  r"^\s*\#endif.*?(?<!\\)\n" is(comment.preproc) -> pop
  r".*?\n" is(comment)

lex(whitespace):
  r"^\#if\s+0" is(comment.preproc) -> go-to(if0)
  r"^\#" is(comment.preproc) -> go-to(macro)
  r"^(?:\s|//.*?\n|/[*].*?[*]/)+\#if\s+0" is(comment.preproc) -> go-to(if0)
  r"^(?:\s|//.*?\n|/[*].*?[*]/)+\#" is(comment.preproc) -> go-to(macro)
  r"\n" is(text)
  r"\s+" is(text)
  r"\\\n" is(text)
  r"//(\n|(.|\n)*?[^\\]\n)" is(comment.single)
  r"/(\\\n)?[*](.|\n)*?[*](\\\n)?/" is(comment.multiline)

lex(macro):
  r"[^/\n]+" is(comment.preproc)
  r"/[*](.|\n)*?[*]/" is(comment.multiline)
  r"//.*?\n" is(comment.single) -> pop
  r"/" is(comment.preproc)
  r"(?<=\\)\n" is(comment.preproc)
  r"\n" is(comment.preproc) -> pop

lex(statement):
  any-of(whitespace)
  any-of(statements)
  r"[{}]" is(punctuation)
  r";" is(punctuation) -> pop

lex(root):
  any-of(whitespace)
  r"((?:[a-zA-Z0-9_*\s])+?(?:\s|[*]))([a-zA-Z$_][a-zA-Z0-9$_]*)(\s*\([^;]*?\))((?:\s|//.*?\n|/[*].*?[*]/)+)({)" is(by-groups(using(self class), name.function, using(self class), text, punctuation)) -> go-to(function)
  r"^([-+])(\s*)(\(.*?\))?(\s*)([a-zA-Z$_][a-zA-Z0-9$_]*:?)" is(by-groups(keyword, text, using(self class), text, name.function)) -> go-to(method)
  r"((?:[a-zA-Z0-9_*\s])+?(?:\s|[*]))([a-zA-Z$_][a-zA-Z0-9$_]*)(\s*\([^;]*?\))((?:\s|//.*?\n|/[*].*?[*]/)+)(;)" is(by-groups(using(self class), name.function, using(self class), text, punctuation))
  r"(@interface|@implementation)(\s+)" is(by-groups(keyword, text)) -> go-to(classname)
  r"(@class|@protocol)(\s+)" is(by-groups(keyword, text)) -> go-to(forward-classname)
  r"(\s*)(@end)(\s*)" is(by-groups(text, keyword, text))
  r"" is(text) -> go-to(statement)

lex(method):
  any-of(whitespace)
  r"(\(.*?\))([a-zA-Z$_][a-zA-Z0-9$_]*)" is(by-groups(using(self class), name.variable))
  r"[a-zA-Z$_][a-zA-Z0-9$_]*:" is(name.function)
  r";" is(punctuation) -> pop
  r"{" is(punctuation) -> go-to(function)
  r"" is(text) -> pop

