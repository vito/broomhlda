macro (lexer(name, &body))
  `(class(~name < HL::Lexers::Lexer):
      @matchers = Hash new
      @info = Hash new

      ~body call)

for-macro class(<< self):
  short-name(["name", "constant"]) := "no"
  short-name(["name", "entity"]) := "ni"
  short-name(["name", "property"]) := "py"
  short-name(["literal", b]) := short-name([b])
  short-name([a, "other"]) := short-name([a]) + "x"
  short-name([a, "error"]) := short-name([a]) + "r"
  short-name([a, "single"]) := short-name([a]) + "1"
  short-name([a, "double"]) := short-name([a]) + "2"
  short-name([a, b]) := short-name([a]) + short-name([b])
  short-name(["error"]) := "err"
  short-name(["number"]) := "m"
  short-name([x]) := x slice(0, 1)
  short-name(_ . xs) := short-name(xs)

  type-from(x: Atomo::AST::Variable) := do:
    tag = Atomo::AST::String new(0, short-name(x name split(".")))
    `(HL::Tokens::Tagged new(~tag))

  type-from(gs: `(by-groups())) := do:
    msg = '(HL::Tokens::ByGroups new)
    msg arguments = [Atomo::AST::List new(0, gs arguments collect (a): type-from(a))]
    msg

  type-from(`(using(~who))) := do:
    `(HL::Tokens::Using new(~who))

  type-from(x) := raise("unknown match type: " + x inspect)

  regexp-from(x) :=
    `((x): Regexp new(
        x source
        x options | @info fetch(#flags)
      ); call(~x))

macro (lex(name, &tokens)) do:
  branches = '[]

  body = []

  tokens contents each (c):
    c match:
      -- implicit continue state
      `(~x is(~y)) ->
        branches elements <<
          `(HL::Matcher new(
              ~(regexp-from(x))
              ~(type-from(y))
              HL::States::Continue new
            ))

      -- specifying a state
      `(~x is(~y) -> ~state) -> do:
        z = state match:
          'pop -> '(HL::States::Pop new)
          'push -> '(HL::States::Push new)
          'continue -> '(HL::States::Continue new)

          `(do-all()) -> do:
            all = '[]
            all elements = state arguments
            `(HL::States::DoAll new(~all))

          `(pop(~n)) ->
            `(HL::States::PopNum new(~n))

          -- TODO: combined, do-all
          `(go-to(~n)) ->
            `(HL::States::GoTo new(#(~n)))

          _ -> raise("unknown state: " + state inspect)

        branches elements <<
          `(HL::Matcher new(
              ~(regexp-from(x))
              ~(type-from(y))
              ~z
            ))

      -- goto shortcut
      `(~x is(~y) => ~z) ->
        branches elements <<
          `(HL::Matcher new(
              ~(regexp-from(x))
              ~(type-from(y))
              HL::States::GoTo new(#~z)
            ))

      `(any-of(~any)) ->
        branches elements <<
          `(@matchers fetch(#~any) call) -- TODO: parameterization?

      _ -> body << c

  body << branches

  tokens contents = body

  `(@matchers at(#~name) put(~tokens))
