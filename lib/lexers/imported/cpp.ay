namespace(broomhlda)

lexer(HL::Lexers::Cpp):

name: "C++"
aliases: ["cpp", "c++"]
extensions: [".cpp", ".hpp", ".c++", ".h++", ".cc", ".hh", ".cxx", ".hxx"]
mimetypes: ["text/x-c++hdr", "text/x-c++src"]
start: #root
flags: 0

lex(classname):
  Regexp new("[a-zA-Z_][a-zA-Z0-9_]*") is(name.class) -> pop
  Regexp new("\\s*(?=>)") is(text) -> pop

lex(macro):
  Regexp new("[^/\\n]+") is(comment.preproc)
  Regexp new("/[*](.|\\n)*?[*]/") is(comment.multiline)
  Regexp new("//.*?\\n") is(comment.single) -> pop
  Regexp new("/") is(comment.preproc)
  Regexp new("(?<=\\\\)\\n") is(comment.preproc)
  Regexp new("\\n") is(comment.preproc) -> pop

lex(root):
  Regexp new("^#if\\s+0") is(comment.preproc) -> go-to(if0)
  Regexp new("^#") is(comment.preproc) -> go-to(macro)
  Regexp new("^(?:\\s|//.*?\\n|/[*].*?[*]/)+#if\\s+0") is(comment.preproc) -> go-to(if0)
  Regexp new("^(?:\\s|//.*?\\n|/[*].*?[*]/)+#") is(comment.preproc) -> go-to(macro)
  Regexp new("\\n") is(text)
  Regexp new("\\s+") is(text)
  Regexp new("\\\\\\n") is(text)
  Regexp new("/(\\\\\\n)?/(\\n|(.|\\n)*?[^\\\\]\\n)") is(comment.single)
  Regexp new("/(\\\\\\n)?[*](.|\\n)*?[*](\\\\\\n)?/") is(comment.multiline)
  Regexp new("[{}]") is(punctuation)
  Regexp new("L?\"") is(literal.string) -> go-to(string)
  Regexp new("L?'(\\\\.|\\\\[0-7]{1,3}|\\\\x[a-fA-F0-9]{1,2}|[^\\\\\\'\\n])'") is(literal.string.char)
  Regexp new("(\\d+\\.\\d*|\\.\\d+|\\d+)[eE][+-]?\\d+[LlUu]*") is(literal.number.float)
  Regexp new("(\\d+\\.\\d*|\\.\\d+|\\d+[fF])[fF]?") is(literal.number.float)
  Regexp new("0x[0-9a-fA-F]+[LlUu]*") is(literal.number.hex)
  Regexp new("0[0-7]+[LlUu]*") is(literal.number.oct)
  Regexp new("\\d+[LlUu]*") is(literal.number.integer)
  Regexp new("\\*/") is(error)
  Regexp new("[\126!%^&*+=|?:<>/-]") is(operator)
  Regexp new("[()\\[\\],.;]") is(punctuation)
  Regexp new("(asm|auto|break|case|catch|const|const_cast|continue|default|delete|do|dynamic_cast|else|enum|explicit|export|extern|for|friend|goto|if|mutable|namespace|new|operator|private|protected|public|register|reinterpret_cast|return|restrict|sizeof|static|static_cast|struct|switch|template|this|throw|throws|try|typedef|typeid|typename|union|using|volatile|virtual|while)\\b") is(keyword)
  Regexp new("(class)(\\s+)") is(by-groups(keyword, text)) -> go-to(classname)
  Regexp new("(bool|int|long|float|short|double|char|unsigned|signed|void|wchar_t)\\b") is(keyword.type)
  Regexp new("(_{0,2}inline|naked|thread)\\b") is(keyword.reserved)
  Regexp new("__(asm|int8|based|except|int16|stdcall|cdecl|fastcall|int32|declspec|finally|int64|try|leave|wchar_t|w64|virtual_inheritance|uuidof|unaligned|super|single_inheritance|raise|noop|multiple_inheritance|m128i|m128d|m128|m64|interface|identifier|forceinline|event|assume)\\b") is(keyword.reserved)
  Regexp new("(__offload|__blockingoffload|__outer)\\b") is(keyword.psuedo)
  Regexp new("(true|false)\\b") is(keyword.constant)
  Regexp new("NULL\\b") is(name.builtin)
  Regexp new("[a-zA-Z_][a-zA-Z0-9_]*:(?!:)") is(name.label)
  Regexp new("[a-zA-Z_][a-zA-Z0-9_]*") is(name)

lex(string):
  Regexp new("\"") is(literal.string) -> pop
  Regexp new("\\\\([\\\\abfnrtv\"\\']|x[a-fA-F0-9]{2,4}|[0-7]{1,3})") is(literal.string.escape)
  Regexp new("[^\\\\\"\\n]+") is(literal.string)
  Regexp new("\\\\\\n") is(literal.string)
  Regexp new("\\\\") is(literal.string)

lex(if0):
  Regexp new("^\\s*#if.*?(?<!\\\\)\\n") is(comment.preproc) -> push
  Regexp new("^\\s*#endif.*?(?<!\\\\)\\n") is(comment.preproc) -> pop
  Regexp new(".*?\\n") is(comment)

