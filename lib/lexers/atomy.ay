lexer(HL::Lexers::Atomy):
  name: "Atomy"
  aliases: "atomy"
  extensions: [".ay"]
  mimetypes: "text/x-atomy"
  start: #root
  flags: Regexp::MULTILINE

  @@identifier =
    raw"[a-z_][[:alnum:]\$\+\<=\>\^~!@#%&*\-.\/\?]*"

  @@operator = raw"[\$\+\<=\>\^~!@&#%\|&*\-.\/\?:]"

  @@reserved =
    raw"(operator|macro|for-macro|self)\b(?!" + @@operator + ")"

  @@ascii = [
    "NUL","SOH","[SE]TX","EOT","ENQ","ACK",
    "BEL","BS","HT","LF","VT","FF","CR","S[OI]","DLE",
    "DC[1-4]","NAK","SYN","ETB","CAN",
    "EM","SUB","ESC","[FGRU]S","SP","DEL"
  ]


  -- starting point for lexing
  lex(root):
    -- comments
    r"--.*?$" is(comment.single)
    r"{-" is(comment.multiline) => in-comment

    -- primitive constants
    r"true|false|nil" is(keyword.constant)

    -- constants
    r"[A-Z][a-zA-Z0-9_]*" is(name.constant)

    -- floats
    r"[\+\-]?\d+[eE][\+\-]?\d+" is(number.float)
    r"[\+\-]?\d+\.\d+([eE][\+\-]?\d+)?" is(number.float)

    -- integers
    r"[\+\-]?0[oO][0-7]+" is(number.octal)
    r"[\+\-]?0[xX][\da-fA-F]+" is(number.hexadecimal)
    r"[\+\-]?\d+" is(number.integer)

    -- reserved words
    Regexp new(@@reserved) is(keyword.reserved)

    -- macro-quotes
    Regexp new("(" + @@identifier + raw")([\"`'{\[])")
      is(string.other) => macro-quote

    -- special variables
    Regexp new("@@" + @@identifier) is(name.variable.class)
    Regexp new("$" + @@identifier) is(name.variable.global)
    Regexp new("@" + @@identifier) is(name.variable.instance)

    -- particles
    Regexp new("#" + @@identifier) is(string.symbol)

    -- identifiers
    Regexp new(@@identifier) is(name)

    -- operators
    Regexp new(@@operator) is(operator)

    -- strings
    r"\"" is(string) => in-string

    -- whitespace
    r"\s+" is(text)

    -- quoting expressions
    Regexp new("['`]" + @@identifier) is(string.symbol)
    r"['`]'" is(string.symbol)

    -- unquote
    Regexp new("~" + @@identifier) is(string.interpolate)
    r"~" is(string.interpolate)

    -- punctuation
    r"[\[\](),;{}|]" is(punctuation)


  -- inside of a block comment; handle nesting
  lex(in-comment):
    r"[^\-\{\}]+" is(comment.multiline)
    r"{-" is(comment.multiline) -> push
    r"-}" is(comment.multiline) -> pop
    r"[-{}]" is(comment.mutline)


  -- inside of a string; contain escapes
  lex(in-string):
    r"[^\\\"]+" is(string)
    r"\\" is(string.escape) => escape
    r"\"" is(string) -> pop


  -- all of our character escapes
  lex(escape):
    r"[nsrtvfbae\\\"]" is(string.escape) -> pop
    r"\^[\]\[A-Z@\^_]" is(string.escape) -> pop
    Regexp new(@@ascii join("|")) is(string.escape) -> pop
    r"o[0-7]+" is(string.escape) -> pop
    r"x[\da-fA-F]+" is(string.escape) -> pop
    r"\d+" is(string.escape) -> pop
    r"\s+\\" is(string.escape) -> pop


  class(<< self):
    -- determine the closing delimiter for a macro-quote
    pair("{") := "}"
    pair("[") := "]"
    pair(x) := x

  -- match delimiters in a macro-quote, skipping escapes
  lex(macro-quote) [d]:
    close = Regexp quote(pair(d captures [1]))

    Regexp new(raw"[^\\" + close + "]+")
      is(string.other)

    r"\\." is(string.other)

    Regexp new(close + "([[:alpha:]]*)")
      is(string.other) -> pop
